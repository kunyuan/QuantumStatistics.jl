var documenterSearchIndex = {"docs":
[{"location":"lib/utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"lib/utility/","page":"Utility","title":"Utility","text":"Modules = [QuantumStatistics.Utility]","category":"page"},{"location":"lib/utility/#QuantumStatistics.Utility","page":"Utility","title":"QuantumStatistics.Utility","text":"Utility data structures and functions\n\n\n\n\n\n","category":"module"},{"location":"lib/utility/#QuantumStatistics.Utility.StopWatch","page":"Utility","title":"QuantumStatistics.Utility.StopWatch","text":"StopWatch(start, interval, callback)\n\nInitialize a stopwatch. \n\nArguments\n\nstart::Float64: initial time (in seconds)\ninterval::Float64 : interval to click (in seconds)\ncallback : callback function after each click (interval seconds)\n\n\n\n\n\n","category":"type"},{"location":"lib/utility/#QuantumStatistics.Utility.check-Tuple{QuantumStatistics.Utility.StopWatch,Vararg{Any,N} where N}","page":"Utility","title":"QuantumStatistics.Utility.check","text":"check(stopwatch, parameter...)\n\nCheck stopwatch. If it clicks, call the callback function with the unpacked parameter\n\n\n\n\n\n","category":"method"},{"location":"lib/twopoint/#Two-point-correlators","page":"Two-point correlators","title":"Two-point correlators","text":"","category":"section"},{"location":"lib/twopoint/","page":"Two-point correlators","title":"Two-point correlators","text":"Modules = [QuantumStatistics.TwoPoint]","category":"page"},{"location":"lib/twopoint/#QuantumStatistics.TwoPoint","page":"Two-point correlators","title":"QuantumStatistics.TwoPoint","text":"Provide N-body response and correlation functions\n\n\n\n\n\n","category":"module"},{"location":"lib/twopoint/#QuantumStatistics.TwoPoint.LindhardΩnFiniteTemperature-Union{Tuple{T}, Tuple{Int64,T,Int64,T,T,T,Any}} where T<:AbstractFloat","page":"Two-point correlators","title":"QuantumStatistics.TwoPoint.LindhardΩnFiniteTemperature","text":"LindhardΩnFiniteTemperature(dim::Int, q::T, n::Int, kF::T, β::T, m::T, spin) where {T <: AbstractFloat}\n\nCompute the polarization function of free electrons at a given frequency. Relative Accuracy is about ~ 1e-6\n\nArguments\n\ndim: dimension\nq: external momentum, q<1e-4 will be treated as q=0 \nn: externel Matsubara frequency, ωn=2π*n/β\nkF: Fermi momentum \nβ: inverse temperature\nm: mass\nspin : number of spins\n\n\n\n\n\n","category":"method"},{"location":"lib/twopoint/#QuantumStatistics.TwoPoint.freePropagatorT-NTuple{4,Any}","page":"Two-point correlators","title":"QuantumStatistics.TwoPoint.freePropagatorT","text":"freePropagatorT(type, τ, ω, β)\n\nImaginary-time propagator.\n\nArguments\n\ntype: symbol :fermi, :bose\nτ: the imaginary time, must be (-β, β]\nω: dispersion ϵ_k-μ\nβ = 1.0: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/twopoint/#QuantumStatistics.TwoPoint.freePropagatorΩ-Tuple{Any,Int64,Any,Any}","page":"Two-point correlators","title":"QuantumStatistics.TwoPoint.freePropagatorΩ","text":"freePropagatorΩ(type, n, ω, β=1.0)\n\nMatsubara-frequency kernel of different type\n\nArguments\n\ntype: symbol :fermi, :bose, :corr\nn: index of the Matsubara frequency\nω: dispersion ϵ_k-μ\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#Discrete-Lehmann-Representation","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"","category":"section"},{"location":"lib/dlr/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"Modules = [QuantumStatistics.DLR]","category":"page"},{"location":"lib/dlr/#QuantumStatistics.DLR","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR","text":"discrete Lehmann representation for imaginary-time/Matsubara-freqeuncy correlator\n\n\n\n\n\n","category":"module"},{"location":"lib/dlr/#QuantumStatistics.DLR.DLRGrid","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.DLRGrid","text":"struct DLRGrid\n\nDLR grids for imaginary-time/Matsubara frequency correlators\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\nEuv : the UV energy scale of the spectral density \nβ : inverse temeprature\nΛ: cutoff = UV Energy scale of the spectral density * inverse temperature\nrtol: tolerance absolute error\nsize : number of DLR basis\nω : selected representative real-frequency grid\nn : selected representative Matsubara-frequency grid (integer)\nωn : (2n+1)π/β\nτ : selected representative imaginary-time grid\n\n\n\n\n\n","category":"type"},{"location":"lib/dlr/#QuantumStatistics.DLR.barycheb-NTuple{5,Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.barycheb","text":"function barycheb(n, x, f, wc, xc)\n\nBarycentric Lagrange interpolation at Chebyshev nodes Reference: Berrut, J.P. and Trefethen, L.N., 2004. Barycentric lagrange interpolation. SIAM review, 46(3), pp.501-517.\n\nArguments\n\nn: order of the Chebyshev interpolation\nx: coordinate to interpolate\nf: array of size n, function at the Chebyshev nodes\nwc: array of size n, Barycentric Lagrange interpolation weights\nxc: array of size n, coordinates of Chebyshev nodes\n\nReturns\n\nInterpolation result\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.barychebinit-Tuple{Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.barychebinit","text":"barychebinit(n)\n\nGet Chebyshev nodes of first kind and corresponding barycentric Lagrange interpolation weights.  Reference: Berrut, J.P. and Trefethen, L.N., 2004. Barycentric lagrange interpolation. SIAM review, 46(3), pp.501-517.\n\nArguments\n\nn: order of the Chebyshev interpolation\n\nReturns\n\nChebyshev nodes\nBarycentric Lagrange interpolation weights\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.dlr-Tuple{Any,Any,Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.dlr","text":"function dlr(type, Λ, rtol)     Construct discrete Lehmann representation\n\n#Arguments:\n\ntype: type of kernel, :fermi, :boson\nΛ: cutoff = UV Energy scale of the spectral density * inverse temperature\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.dlr2matfreq","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.dlr2matfreq","text":"function dlr2matfreq(type, dlrcoeff, dlrGrid::DLRGrid, nGrid, β=1.0; axis=1)\n\nDLR representation to Matsubara-frequency representation\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\ndlrcoeff : DLR coefficients\ndlrGrid : DLRGrid\nnGrid : expected fine Matsubara-freqeuncy grids (integer)\naxis: Matsubara-frequency axis in the data dlrcoeff\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"function"},{"location":"lib/dlr/#QuantumStatistics.DLR.dlr2tau-Tuple{Any,Any,QuantumStatistics.DLR.DLRGrid,Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.dlr2tau","text":"function dlr2tau(type, dlrcoeff, dlrGrid::DLRGrid, τGrid; axis=1)\n\nDLR representation to imaginary-time representation\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\ndlrcoeff : DLR coefficients\ndlrGrid : DLRGrid\nτGrid : expected fine imaginary-time grids ∈ (0, β]\naxis: imaginary-time axis in the data dlrcoeff\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.kernalDiscretization-NTuple{5,Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.kernalDiscretization","text":"kernalDiscretization(type, Nτ, Nω, Λ, rtol)\n\nDiscretize kernel K(tau,omega) on composite Chebyshev fine grids for τ and ω.  Generate a panels and grids for τ and ω.\n\n#Arguments:\n\ntype: :fermi, :bose or :corr\nDτ: Chebyshev degree in each τ panel\nDω: Chebyshev degree in each ω panel\nΛ: cutoff = UV Energy scale of the spectral density * inverse temperature\nrtol: tolerance relative error\n\n#Returns\n\nτPanel: panel break points for τ, exponentially get dense near 0⁺ and 1⁻\nωPanel: panel break points for ω, get exponentially dense near 0⁻ and 0⁺\nτGrid: tau fine grid points on (0,1)\nωGrid: omega fine grid points on (-Λ, Λ)\nkernel: K(tau,omega) on fine grid \nerr: Error of composite Chebyshev interpolant of K(tau,omega). err(1) is ~= max relative L^inf error in tau over all omega in fine grid. err(2) is ~= max L^inf error in omega over all tau in fine grid.\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.matfreq2dlr-Tuple{Any,Any,QuantumStatistics.DLR.DLRGrid}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.matfreq2dlr","text":"function matfreq2dlr(type, green, dlrGrid::DLRGrid; axis=1, rtol=1e-12)\n\nMatsubara-frequency representation to DLR representation\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\ngreen : green's function in Matsubara-frequency domain\naxis: the Matsubara-frequency axis in the data green\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.matfreq2tau-NTuple{4,Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.matfreq2tau","text":"function matfreq2tau(type, green, dlrGrid, τGrid; axis=1, rtol=1e-12)\n\nFourier transform from Matsubara-frequency to imaginary-time using the DLR representation\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\ngreen : green's function in Matsubara-freqeuncy repsentation\ndlrGrid : DLRGrid\nτGrid : expected fine imaginary-time grids\naxis: Matsubara-frequency axis in the data green\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.tau2dlr-Tuple{Any,Any,QuantumStatistics.DLR.DLRGrid}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.tau2dlr","text":"function tau2dlr(type, green, dlrGrid::DLRGrid; axis=1, rtol=1e-12)\n\nimaginary-time domain to DLR representation\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\ngreen : green's function in imaginary-time domain\naxis: the imaginary-time axis in the data green\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.tau2matfreq-NTuple{4,Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.tau2matfreq","text":"function tau2matfreq(type, green, dlrGrid, nGrid; axis=1, rtol=1e-12)\n\nFourier transform from imaginary-time to Matsubara-frequency using the DLR representation\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\ngreen : green's function in imaginary-time domain\ndlrGrid : DLRGrid\nnGrid : expected fine Matsubara-freqeuncy grids (integer)\naxis: the imaginary-time axis in the data green\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"method"},{"location":"lib/montecarlo/#Monte-Carlo","page":"Monte Carlo","title":"Monte Carlo","text":"","category":"section"},{"location":"lib/montecarlo/","page":"Monte Carlo","title":"Monte Carlo","text":"Modules = [QuantumStatistics.MonteCarlo]","category":"page"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo","text":"Monte Carlo Calculator for Diagrams\n\n\n\n\n\n","category":"module"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.Diagram","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.Diagram","text":"Group{A}(type::Int, internal::Tuple{Vararg{Int}}, external::Tuple{Vararg{Int}}, eval, obstype=Float64)\n\ncreate a group of diagrams\n\n#Arguments:\n\ntype: integer identifier of the group\ninternal: internal variable numbers, e.g. [number of internal momentum, number of internal tau]\nexternal: array of size of external index, e.g. [size of external momentum index, size of external tau]\neval: function to evaluate the group\nobstype: type of the diagram weight, e.g. Float64\n\n\n\n\n\n","category":"type"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.create!","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.create!","text":"createIdx!(newIdx::Int, size::Int, rng=GLOBAL_RNG)\n\nPropose to generate new index (uniformly) randomly in [1, size]\n\nArguments\n\nnewIdx:  index ∈ [1, size]\nsize : up limit of the index\nrng=GLOBAL_RNG : random number generator\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.create!-2","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.create!","text":"create!(T::Tau, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate new tau (uniformly) randomly in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.create!-3","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.create!","text":"create!(T::TauPair, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate a new pair of tau (uniformly) randomly in [0, β), return proposal probability\n\nArguments\n\nT:  TauPair variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.create!-4","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.create!","text":"create!(theta::Angle, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate new angle (uniformly) randomly in [0, 2π), return proposal probability\n\nArguments\n\ntheta:  angle variable\nidx: theta.t[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.create!-Union{Tuple{D}, Tuple{QuantumStatistics.MonteCarlo.FermiK{D},Int64}, Tuple{QuantumStatistics.MonteCarlo.FermiK{D},Int64,Any}} where D","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.create!","text":"create!(K::FermiK{D}, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate new Fermi K in [Kf-δK, Kf+δK)\n\nArguments\n\nnewK:  vector of dimension of d=2 or 3\n\n\n\n\n\n","category":"method"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.progressBar-Tuple{Any,Any}","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.progressBar","text":"progressBar(step, total)\n\nReturn string of progressBar (step/total*100%)\n\n\n\n\n\n","category":"method"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.remove","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.remove","text":"removeIdx!(newIdx::Int, size::Int, rng=GLOBAL_RNG)\n\nPropose to remove the old index in [1, size]\n\nArguments\n\noldIdx:  index ∈ [1, size]\nsize : up limit of the index\nrng=GLOBAL_RNG : random number generator\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.remove-2","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.remove","text":"remove(T::Tau, idx::Int, rng=GLOBAL_RNG)\n\nPropose to remove old tau in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.remove-3","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.remove","text":"remove(T::TauPair, idx::Int, rng=GLOBAL_RNG)\n\nPropose to remove an existing pair of tau in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.remove-4","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.remove","text":"remove(theta::Angle, idx::Int, rng=GLOBAL_RNG)\n\nPropose to remove old theta in [0, 2π), return proposal probability\n\nArguments\n\n- `theta`:  Tau variable\n\nidx: theta.t[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.remove-Union{Tuple{D}, Tuple{QuantumStatistics.MonteCarlo.FermiK{D},Int64}, Tuple{QuantumStatistics.MonteCarlo.FermiK{D},Int64,Any}} where D","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.remove","text":"removeFermiK!(oldK, Kf=1.0, δK=0.5, rng=GLOBAL_RNG)\n\nPropose to remove an existing Fermi K in [Kf-δK, Kf+δK)\n\nArguments\n\noldK:  vector of dimension of d=2 or 3\n\n\n\n\n\n","category":"method"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.shift!","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.shift!","text":"shiftIdx!(oldIdx::Int, newIdx::Int, size::Int, rng=GLOBAL_RNG)\n\nPropose to shift the old index in [1, size] to a new index\n\nArguments\n\noldIdx:  old index ∈ [1, size]\nnewIdx:  new index ∈ [1, size], will be modified!\nsize : up limit of the index\nrng=GLOBAL_RNG : random number generator\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.shift!-2","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.shift!","text":"shift!(T::Tau, idx::Int, rng=GLOBAL_RNG)\n\nPropose to shift an existing tau to a new tau, both in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.shift!-3","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.shift!","text":"shift!(T::TauPair, idx::Int, rng=GLOBAL_RNG)\n\nPropose to shift an existing tau pair to a new tau pair, both in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.t[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.shift!-4","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.shift!","text":"shift!(theta::Angle, idx::Int, rng=GLOBAL_RNG)\n\nPropose to shift the old theta to new theta, both in [0, 2π), return proposal probability\n\nArguments\n\ntheta:  angle variable\nidx: theta.t[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.shift!-Union{Tuple{D}, Tuple{QuantumStatistics.MonteCarlo.FermiK{D},Int64}, Tuple{QuantumStatistics.MonteCarlo.FermiK{D},Int64,Any}} where D","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.shift!","text":"shiftK!(oldK, newK, step, rng=GLOBAL_RNG)\n\nPropose to shift oldK to newK. Work for generic momentum vector\n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#Spectral-functions","page":"Spectral functions","title":"Spectral functions","text":"","category":"section"},{"location":"lib/spectral/","page":"Spectral functions","title":"Spectral functions","text":"Modules = [QuantumStatistics.Spectral]","category":"page"},{"location":"lib/spectral/#QuantumStatistics.Spectral","page":"Spectral functions","title":"QuantumStatistics.Spectral","text":"Spectral representation related functions\n\n\n\n\n\n","category":"module"},{"location":"lib/spectral/#QuantumStatistics.Spectral.boseEinstein-Union{Tuple{T}, Tuple{T}, Tuple{T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.boseEinstein","text":"boseEinstein(ω)\n\nCompute the Fermi Dirac function. Assume k_B Thbar=1\n\nf(ω) = 1(e^ωβ-1)\n\nArguments\n\nω: frequency\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.density-Union{Tuple{T}, Tuple{Symbol,T}, Tuple{Symbol,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.density","text":"density(type, ω, β=1.0)\n\nCompute the imaginary-time kernel of different type. Assume k_B Thbar=1\n\nArguments\n\ntype: symbol :fermi, :bose\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.fermiDirac-Union{Tuple{T}, Tuple{T}, Tuple{T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.fermiDirac","text":"fermiDirac(ω)\n\nCompute the Fermi Dirac function. Assume k_B Thbar=1\n\nf(ω) = 1(e^ωβ+1)\n\nArguments\n\nω: frequency\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.freq2matfreq","page":"Spectral functions","title":"QuantumStatistics.Spectral.freq2matfreq","text":"freq2matfreq(type, spectral, nGrid, β=1.0, Emin=-Inf, Emax=Inf, rtol=1e-12)\n\nCompute Matubra frequency Green's function from a spectral density``\n\nG(iωn) = dω -1(iωn-ω) S(ω)\nwhere ωn=(2n+1)πβ for fermion and ωn=2nπβ\n\nArguments\n\ntype: :fermi, :boson\nspectral: call spectral(ω) returns the spectral density\nnGrid: array of Matsubara frequency (integer!) to evaluate\nβ=1.0: inverse temperature\nEmin=-Inf: lower bound of frequency\nEmax=Inf: upper bound of frequency\nrtol=1e-12: accuracy to achieve\n\n\n\n\n\n","category":"function"},{"location":"lib/spectral/#QuantumStatistics.Spectral.freq2tau","page":"Spectral functions","title":"QuantumStatistics.Spectral.freq2tau","text":"freq2tau(type, spectral, τGrid, β=1.0, Emin=-Inf, Emax=Inf, rtol=1e-12)\n\nCompute imaginary-time Green's function from a spectral density``\n\nG(τ0) = dω e^-ωτ(1e^-ωβ) S(ω)\nG(τ0) = -dω e^-ωτ(1e^ωβ) S(ω)\n\nArguments\n\ntype: :fermi, :boson\nintegrator: :quadgk, :vegas, :cuhre\nspectral: call spectral(ω) returns the spectral density\nτGrid: array of imaginary times to evaluate\nβ=1.0: inverse temperature\nEmin=-Inf: lower bound of frequency\nEmax=Inf: upper bound of frequency\nrtol=1e-12: accuracy to achieve\n\n\n\n\n\n","category":"function"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelBoseT-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelBoseT","text":"kernelBoseT(τ, ω, β=1.0)\n\nCompute the imaginary-time bosonic kernel. Machine accuracy ~eps(g) is guaranteed``\n\ng(τ0) = e^-ωτ(1-e^-ωβ) g(τ0) = -e^-ωτ(1-e^ωβ)\n\nArguments\n\nτ: the imaginary time, must be (-β, β]\nω: frequency\nβ = 1.0: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelBoseΩ-Union{Tuple{T}, Tuple{Int64,T}, Tuple{Int64,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelBoseΩ","text":"kernelBoseΩ(n::Int, ω::T, β::T) where {T <: AbstractFloat}\n\nCompute the bosonic kernel with Matsubara frequency.\n\ng(iω_n) = -1(iω_n-ω)\n\nwhere ω_n=2nπβ. The convention here is consist with the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95\n\nArguments\n\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelCorrT-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelCorrT","text":"kernelCorrT(τ, ω, β=1.0)\n\nCompute the imaginary-time kernel for correlation function O(τ)O(0). Machine accuracy ~eps(C) is guaranteed``\n\nK(τ) = e^-ωτ+e^-ω(β-τ)\n\nArguments\n\nτ: the imaginary time, must be (-β, β]\nω: frequency\nβ = 1.0: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelCorrΩ-Union{Tuple{T}, Tuple{Int64,T}, Tuple{Int64,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelCorrΩ","text":"kernelCorrΩ(n::Int, ω::T, β::T) where {T <: AbstractFloat}\n\nCompute the Matsubara-frequency kernel for a correlator O(τ)O(0)_iω_n.\n\nK(iω_n) = frac2ωω^2+ω_n^2(1-e^-ωβ)\n\nwhere ω_n=2nπβ. The convention here is consist with the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95\n\nArguments\n\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelFermiT-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelFermiT","text":"kernelFermiT(τ, ω, β=1.0)\n\nCompute the imaginary-time fermionic kernel.  Machine accuracy ~eps(g) is guaranteed``\n\ng(τ0) = e^-ωτ(1+e^-ωβ) g(τ0) = -e^-ωτ(1+e^ωβ)\n\nArguments\n\nτ: the imaginary time, must be (-β, β]\nω: frequency\nβ = 1.0: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelFermiΩ-Union{Tuple{T}, Tuple{Int64,T}, Tuple{Int64,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelFermiΩ","text":"kernelFermiΩ(n::Int, ω::T, β::T) where {T <: AbstractFloat}\n\nCompute the fermionic kernel with Matsubara frequency.\n\ng(iω_n) = -1(iω_n-ω)\n\nwhere ω_n=(2n+1)πβ. The convention here is consist with the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95\n\nArguments\n\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelT-Union{Tuple{T}, Tuple{Symbol,AbstractArray{T,1},AbstractArray{T,1}}, Tuple{Symbol,AbstractArray{T,1},AbstractArray{T,1},Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelT","text":"kernelT(type::Symbol, τGrid::Vector{T}, ωGrid::Vector{T}, β::T=1.0) where {T<:AbstractFloat}\n\nCompute kernel with given τ and ω grids.\n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelT-Union{Tuple{T}, Tuple{Symbol,T,T}, Tuple{Symbol,T,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelT","text":"kernelT(type, τ, ω, β=1.0)\n\nCompute the imaginary-time kernel of different type.\n\nArguments\n\ntype: symbol :fermi, :bose, :corr\nτ: the imaginary time, must be (-β, β]\nω: frequency\nβ = 1.0: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelΩ-Union{Tuple{T}, Tuple{Symbol,Array{Int64,1},Array{T,1}}, Tuple{Symbol,Array{Int64,1},Array{T,1},Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelΩ","text":"kernelΩ(type::Symbol, nGrid::Vector{Int}, ωGrid::Vector{T}, β::T=1.0) where {T<:AbstractFloat}\n\nCompute kernel matrix with given ωn (integer!) and ω grids.\n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelΩ-Union{Tuple{T}, Tuple{Symbol,Int64,T}, Tuple{Symbol,Int64,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelΩ","text":"kernelΩ(type, n, ω, β=1.0)\n\nCompute the imaginary-time kernel of different type. Assume k_B Thbar=1\n\nArguments\n\ntype: symbol :fermi, :bose, :corr\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"#QuantumStatistics.jl","page":"QuantumStatistics.jl","title":"QuantumStatistics.jl","text":"","category":"section"},{"location":"","page":"QuantumStatistics.jl","title":"QuantumStatistics.jl","text":"A toolbox for quantum many-body field theory.","category":"page"},{"location":"#Outline","page":"QuantumStatistics.jl","title":"Outline","text":"","category":"section"},{"location":"","page":"QuantumStatistics.jl","title":"QuantumStatistics.jl","text":"Pages = [\n    \"lib/grid.md\",\n    \"lib/spectral.md\",\n    \"lib/dlr.md\",\n    \"lib/green.md\",\n    \"lib/twopoint.md\",\n    \"lib/montecarlo.md\",\n    \"lib/fastmath.md\",\n    \"lib/utility.md\",\n]\nDepth = 1","category":"page"},{"location":"lib/fastmath/#Fast-Math-Functions","page":"Fast Math Functions","title":"Fast Math Functions","text":"","category":"section"},{"location":"lib/fastmath/","page":"Fast Math Functions","title":"Fast Math Functions","text":"Modules = [QuantumStatistics.FastMath]","category":"page"},{"location":"lib/fastmath/#QuantumStatistics.FastMath","page":"Fast Math Functions","title":"QuantumStatistics.FastMath","text":"Provide a set of fast math functions\n\n\n\n\n\n","category":"module"},{"location":"lib/fastmath/#QuantumStatistics.FastMath.invsqrt-Tuple{Float64}","page":"Fast Math Functions","title":"QuantumStatistics.FastMath.invsqrt","text":"invsqrt(x)\n\nThe Legendary Fast Inverse Square Root See the following links: wikipedia and thesis\n\n\n\n\n\n","category":"method"},{"location":"lib/grid/#Grids","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"lib/grid/","page":"Grids","title":"Grids","text":"Modules = [QuantumStatistics.Grid]","category":"page"},{"location":"lib/grid/#QuantumStatistics.Grid.Uniform","page":"Grids","title":"QuantumStatistics.Grid.Uniform","text":"Uniform{Type,SIZE}\n\nCreate a uniform Grid with a given type and size\n\nMember:\n\nβ: inverse temperature\nhalfLife: the grid is densest in the range (0, halfLife) and (β-halfLife, β)\nsize: the Grid size\ngrid: vector stores the grid\nsize: size of the grid vector\nhead: grid head\ntail: grid tail\nδ: distance between two grid elements\nisopen: if isopen[1]==true, then grid[1] will be slightly larger than the grid head. Same for the tail.\n\n\n\n\n\n","category":"type"},{"location":"lib/grid/#QuantumStatistics.Grid.boseK","page":"Grids","title":"QuantumStatistics.Grid.boseK","text":"boseK(Kf, maxK, halfLife, size::Int, kFi = floor(Int, 0.5size), twokFi = floor(Int, 2size / 3), type = Float64)\n\nCreate a logarithmic bosonic K Grid, which is densest near the momentum 0 and 2k_F\n\n#Arguments:\n\nKf: Fermi momentum\nmaxK: the upper bound of the grid\nhalfLife: the grid is densest in the range (0, Kf+halfLife) and (2Kf-halfLife, 2Kf+halfLife)\nsize: the Grid size\nkFi: index of Kf\ntwokFi: index of 2Kf\n\n\n\n\n\n","category":"function"},{"location":"lib/grid/#QuantumStatistics.Grid.fermiK","page":"Grids","title":"QuantumStatistics.Grid.fermiK","text":"fermiK(Kf, maxK, halfLife, size::Int, kFi = floor(Int, 0.5size), type = Float64)\n\nCreate a logarithmic fermionic K Grid, which is densest near the Fermi momentum k_F\n\n#Arguments:\n\nKf: Fermi momentum\nmaxK: the upper bound of the grid\nhalfLife: the grid is densest in the range (Kf-halfLife, Kf+halfLife)\nsize: the Grid size\nkFi: index of Kf\n\n\n\n\n\n","category":"function"},{"location":"lib/grid/#QuantumStatistics.Grid.linear2D-NTuple{5,Any}","page":"Grids","title":"QuantumStatistics.Grid.linear2D","text":"linear2D(xgrid, ygrid, data, x, y) \n\nlinear interpolation of data(x, y)\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\nygrid: one-dimensional grid of y\ndata: two-dimensional array of data\nx: x\ny: y\n\n\n\n\n\n","category":"method"},{"location":"lib/grid/#QuantumStatistics.Grid.tau","page":"Grids","title":"QuantumStatistics.Grid.tau","text":"tau(β, halfLife, size::Int, type = Float64)\n\nCreate a logarithmic Grid for the imaginary time, which is densest near the 0 and β\n\n#Arguments:\n\nβ: inverse temperature\nhalfLife: the grid is densest in the range (0, halfLife) and (β-halfLife, β)\nsize: the Grid size\n\n\n\n\n\n","category":"function"}]
}
