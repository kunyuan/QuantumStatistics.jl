var documenterSearchIndex = {"docs":
[{"location":"lib/utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"lib/utility/","page":"Utility","title":"Utility","text":"Modules = [QuantumStatistics.Utility]","category":"page"},{"location":"lib/utility/#QuantumStatistics.Utility","page":"Utility","title":"QuantumStatistics.Utility","text":"Utility data structures and functions\n\n\n\n\n\n","category":"module"},{"location":"lib/utility/#QuantumStatistics.Utility.StopWatch","page":"Utility","title":"QuantumStatistics.Utility.StopWatch","text":"StopWatch(start, interval, callback)\n\nInitialize a stopwatch. \n\nArguments\n\nstart::Float64: initial time (in seconds)\ninterval::Float64 : interval to click (in seconds)\ncallback : callback function after each click (interval seconds)\n\n\n\n\n\n","category":"type"},{"location":"lib/utility/#QuantumStatistics.Utility.check-Tuple{QuantumStatistics.Utility.StopWatch,Vararg{Any,N} where N}","page":"Utility","title":"QuantumStatistics.Utility.check","text":"check(stopwatch, parameter...)\n\nCheck stopwatch. If it clicks, call the callback function with the unpacked parameter\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#QuantumStatistics.Utility.progressBar-Tuple{Any,Any}","page":"Utility","title":"QuantumStatistics.Utility.progressBar","text":"progressBar(step, total)\n\nReturn string of progressBar (step/total*100%)\n\n\n\n\n\n","category":"method"},{"location":"lib/twopoint/#Two-point-correlators","page":"Two-point correlators","title":"Two-point correlators","text":"","category":"section"},{"location":"lib/twopoint/","page":"Two-point correlators","title":"Two-point correlators","text":"Modules = [QuantumStatistics.TwoPoint]","category":"page"},{"location":"lib/twopoint/#QuantumStatistics.TwoPoint","page":"Two-point correlators","title":"QuantumStatistics.TwoPoint","text":"Provide N-body response and correlation functions\n\n\n\n\n\n","category":"module"},{"location":"lib/twopoint/#QuantumStatistics.TwoPoint.LindhardΩnFiniteTemperature-Union{Tuple{T}, Tuple{Int64,T,Int64,T,T,T,Any}} where T<:AbstractFloat","page":"Two-point correlators","title":"QuantumStatistics.TwoPoint.LindhardΩnFiniteTemperature","text":"LindhardΩnFiniteTemperature(dim::Int, q::T, n::Int, kF::T, β::T, m::T, spin) where {T <: AbstractFloat}\n\nCompute the polarization function of free electrons at a given frequency. Relative Accuracy is about ~ 1e-6\n\nArguments\n\ndim: dimension\nq: external momentum, q<1e-4 will be treated as q=0 \nn: externel Matsubara frequency, ωn=2π*n/β\nkF: Fermi momentum \nβ: inverse temperature\nm: mass\nspin : number of spins\n\n\n\n\n\n","category":"method"},{"location":"lib/twopoint/#QuantumStatistics.TwoPoint.freePropagatorT-NTuple{4,Any}","page":"Two-point correlators","title":"QuantumStatistics.TwoPoint.freePropagatorT","text":"freePropagatorT(type, τ, ω, β)\n\nImaginary-time propagator.\n\nArguments\n\ntype: symbol :fermi, :bose\nτ: the imaginary time, must be (-β, β]\nω: dispersion ϵ_k-μ\nβ = 1.0: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/twopoint/#QuantumStatistics.TwoPoint.freePropagatorΩ-Tuple{Any,Int64,Any,Any}","page":"Two-point correlators","title":"QuantumStatistics.TwoPoint.freePropagatorΩ","text":"freePropagatorΩ(type, n, ω, β=1.0)\n\nMatsubara-frequency kernel of different type\n\nArguments\n\ntype: symbol :fermi, :bose, :corr\nn: index of the Matsubara frequency\nω: dispersion ϵ_k-μ\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#Discrete-Lehmann-Representation","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"","category":"section"},{"location":"lib/dlr/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"Modules = [QuantumStatistics.DLR]","category":"page"},{"location":"lib/dlr/#QuantumStatistics.DLR","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR","text":"discrete Lehmann representation for imaginary-time/Matsubara-freqeuncy correlator\n\n\n\n\n\n","category":"module"},{"location":"lib/dlr/#QuantumStatistics.DLR.DLRGrid","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.DLRGrid","text":"struct DLRGrid\n\nDLR grids for imaginary-time/Matsubara frequency correlators\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\nEuv : the UV energy scale of the spectral density \nβ : inverse temeprature\nΛ: cutoff = UV Energy scale of the spectral density * inverse temperature\nrtol: tolerance absolute error\nsize : number of DLR basis\nω : selected representative real-frequency grid\nn : selected representative Matsubara-frequency grid (integer)\nωn : (2n+1)π/β\nτ : selected representative imaginary-time grid\n\n\n\n\n\n","category":"type"},{"location":"lib/dlr/#QuantumStatistics.DLR.barycheb-NTuple{5,Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.barycheb","text":"function barycheb(n, x, f, wc, xc)\n\nBarycentric Lagrange interpolation at Chebyshev nodes Reference: Berrut, J.P. and Trefethen, L.N., 2004. Barycentric lagrange interpolation. SIAM review, 46(3), pp.501-517.\n\nArguments\n\nn: order of the Chebyshev interpolation\nx: coordinate to interpolate\nf: array of size n, function at the Chebyshev nodes\nwc: array of size n, Barycentric Lagrange interpolation weights\nxc: array of size n, coordinates of Chebyshev nodes\n\nReturns\n\nInterpolation result\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.barychebinit-Tuple{Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.barychebinit","text":"barychebinit(n)\n\nGet Chebyshev nodes of first kind and corresponding barycentric Lagrange interpolation weights.  Reference: Berrut, J.P. and Trefethen, L.N., 2004. Barycentric lagrange interpolation. SIAM review, 46(3), pp.501-517.\n\nArguments\n\nn: order of the Chebyshev interpolation\n\nReturns\n\nChebyshev nodes\nBarycentric Lagrange interpolation weights\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.dlr-Tuple{Any,Any,Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.dlr","text":"function dlr(type, Λ, rtol)     Construct discrete Lehmann representation\n\n#Arguments:\n\ntype: type of kernel, :fermi, :boson\nΛ: cutoff = UV Energy scale of the spectral density * inverse temperature\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.dlr2matfreq","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.dlr2matfreq","text":"function dlr2matfreq(type, dlrcoeff, dlrGrid::DLRGrid, nGrid, β=1.0; axis=1)\n\nDLR representation to Matsubara-frequency representation\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\ndlrcoeff : DLR coefficients\ndlrGrid : DLRGrid\nnGrid : expected fine Matsubara-freqeuncy grids (integer)\naxis: Matsubara-frequency axis in the data dlrcoeff\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"function"},{"location":"lib/dlr/#QuantumStatistics.DLR.dlr2tau-Tuple{Any,Any,QuantumStatistics.DLR.DLRGrid,Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.dlr2tau","text":"function dlr2tau(type, dlrcoeff, dlrGrid::DLRGrid, τGrid; axis=1)\n\nDLR representation to imaginary-time representation\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\ndlrcoeff : DLR coefficients\ndlrGrid : DLRGrid\nτGrid : expected fine imaginary-time grids ∈ (0, β]\naxis: imaginary-time axis in the data dlrcoeff\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.kernalDiscretization-NTuple{5,Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.kernalDiscretization","text":"kernalDiscretization(type, Nτ, Nω, Λ, rtol)\n\nDiscretize kernel K(tau,omega) on composite Chebyshev fine grids for τ and ω.  Generate a panels and grids for τ and ω.\n\n#Arguments:\n\ntype: :fermi, :bose or :corr\nDτ: Chebyshev degree in each τ panel\nDω: Chebyshev degree in each ω panel\nΛ: cutoff = UV Energy scale of the spectral density * inverse temperature\nrtol: tolerance relative error\n\n#Returns\n\nτPanel: panel break points for τ, exponentially get dense near 0⁺ and 1⁻\nωPanel: panel break points for ω, get exponentially dense near 0⁻ and 0⁺\nτGrid: tau fine grid points on (0,1)\nωGrid: omega fine grid points on (-Λ, Λ)\nkernel: K(tau,omega) on fine grid \nerr: Error of composite Chebyshev interpolant of K(tau,omega). err(1) is ~= max relative L^inf error in tau over all omega in fine grid. err(2) is ~= max L^inf error in omega over all tau in fine grid.\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.matfreq2dlr-Tuple{Any,Any,QuantumStatistics.DLR.DLRGrid}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.matfreq2dlr","text":"function matfreq2dlr(type, green, dlrGrid::DLRGrid; axis=1, rtol=1e-12)\n\nMatsubara-frequency representation to DLR representation\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\ngreen : green's function in Matsubara-frequency domain\naxis: the Matsubara-frequency axis in the data green\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.matfreq2tau-NTuple{4,Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.matfreq2tau","text":"function matfreq2tau(type, green, dlrGrid, τGrid; axis=1, rtol=1e-12)\n\nFourier transform from Matsubara-frequency to imaginary-time using the DLR representation\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\ngreen : green's function in Matsubara-freqeuncy repsentation\ndlrGrid : DLRGrid\nτGrid : expected fine imaginary-time grids\naxis: Matsubara-frequency axis in the data green\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.tau2dlr-Tuple{Any,Any,QuantumStatistics.DLR.DLRGrid}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.tau2dlr","text":"function tau2dlr(type, green, dlrGrid::DLRGrid; axis=1, rtol=1e-12)\n\nimaginary-time domain to DLR representation\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\ngreen : green's function in imaginary-time domain\naxis: the imaginary-time axis in the data green\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"method"},{"location":"lib/dlr/#QuantumStatistics.DLR.tau2matfreq-NTuple{4,Any}","page":"Discrete Lehmann Representation","title":"QuantumStatistics.DLR.tau2matfreq","text":"function tau2matfreq(type, green, dlrGrid, nGrid; axis=1, rtol=1e-12)\n\nFourier transform from imaginary-time to Matsubara-frequency using the DLR representation\n\n#Members:\n\ntype: symbol :fermi, :bose, :corr\ngreen : green's function in imaginary-time domain\ndlrGrid : DLRGrid\nnGrid : expected fine Matsubara-freqeuncy grids (integer)\naxis: the imaginary-time axis in the data green\nrtol: tolerance absolute error\n\n\n\n\n\n","category":"method"},{"location":"lib/montecarlo/#Monte-Carlo","page":"Monte Carlo","title":"Monte Carlo","text":"","category":"section"},{"location":"lib/montecarlo/","page":"Monte Carlo","title":"Monte Carlo","text":"Modules = [QuantumStatistics.MonteCarlo]","category":"page"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo","text":"Monte Carlo Calculator for Diagrams\n\n\n\n\n\n","category":"module"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.Configuration","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.Configuration","text":"mutable struct Configuration\n\nStruct that contains everything needed for MC.\n\nThere are three different componenets:\n\nMembers\n\nStatic parameters\n\nseed: seed to initialize random numebr generator, also serves as the unique pid of the configuration\nrng: a MersenneTwister random number generator, seeded by seed\npara: user-defined parameter, could be set to nothing if not needed\ntotalStep: the total number of updates for this configuration\nvar: TUPLE of variables, each variable should be derived from the abstract type Variable, see variable.jl for details). Use a tuple rather than a vector improves the performance.\n\nintegrand properties\n\nneighbor::Vector{Vector{Int}} : vectors that indicates the neighbors of each integrand. e.g., ([2, ], [1, ]) means the neighbor of the first integrand is the second one, while the neighbor of the second integrand is the first.    There is a MC update proposes to jump from one integrand to another. If these two integrands' degrees of freedom are very different, then the update is unlikely to be accepted. To avoid this problem, one can specify neighbor to guide the update. \nBy default, we assume the N integrands are in the increase order, meaning the neighbor will be set to ([N+1, 2], [1, 3], [2, 4], ..., [N-1,], [1, ]), where the first N entries are for diagram 1, 2, ..., N and the last entry is for the normalization diagram. Only the first diagram is connected to the normalization diagram.\ndof::Vector{Vector{Int}}: degrees of freedom of each integrand, e.g., [[0, 1], [2, 3]] means the first integrand has zero var#1 and one var#2; while the second integrand has two var#1 and 3 var#2. \nobservable: observables that is required to calculate the integrands, will be used in the measure function call.   It is either an array of any type with the common operations like +-*/^ defined. \nreweight: reweight factors for each integrands. \nvisited: how many times this integrand is visited by the Markov chain.\n\ncurrent MC state\n\nstep: the number of MC updates performed up to now\ncurr: the current integrand, initialize with 1\nnorm: the index of the normalization diagram. norm is larger than the index of any user-defined integrands \nabsWeight: the abolute weight of the current integrand. User is responsible to initialize it after the contructor is called.\nnormalization: the accumulated normalization factor. Physical observable = Configuration.observable/Configuration.normalization.\npropose/accept: array to store the proposed and accepted updates for each integrands and variables.  Their shapes are (number of updates X integrand number X max(integrand number, variable number).  The last index will waste some memory, but the dimension is small anyway.\n\n\n\n\n\n","category":"type"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.create!","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.create!","text":"createIdx!(newIdx::Int, size::Int, rng=GLOBAL_RNG)\n\nPropose to generate new index (uniformly) randomly in [1, size]\n\nArguments\n\nnewIdx:  index ∈ [1, size]\nsize : up limit of the index\nrng=GLOBAL_RNG : random number generator\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.create!-2","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.create!","text":"create!(T::TauPair, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate a new pair of tau (uniformly) randomly in [0, β), return proposal probability\n\nArguments\n\nT:  TauPair variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.create!-3","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.create!","text":"create!(theta::Angle, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate new angle (uniformly) randomly in [0, 2π), return proposal probability\n\nArguments\n\ntheta:  angle variable\nidx: theta.t[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.create!-4","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.create!","text":"create!(T::Tau, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate new tau (uniformly) randomly in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.create!-Union{Tuple{D}, Tuple{QuantumStatistics.MonteCarlo.FermiK{D},Int64}, Tuple{QuantumStatistics.MonteCarlo.FermiK{D},Int64,Any}} where D","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.create!","text":"create!(K::FermiK{D}, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate new Fermi K in [Kf-δK, Kf+δK)\n\nArguments\n\nnewK:  vector of dimension of d=2 or 3\n\n\n\n\n\n","category":"method"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.remove","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.remove","text":"removeIdx!(newIdx::Int, size::Int, rng=GLOBAL_RNG)\n\nPropose to remove the old index in [1, size]\n\nArguments\n\noldIdx:  index ∈ [1, size]\nsize : up limit of the index\nrng=GLOBAL_RNG : random number generator\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.remove-2","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.remove","text":"remove(T::TauPair, idx::Int, rng=GLOBAL_RNG)\n\nPropose to remove an existing pair of tau in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.remove-3","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.remove","text":"remove(theta::Angle, idx::Int, rng=GLOBAL_RNG)\n\nPropose to remove old theta in [0, 2π), return proposal probability\n\nArguments\n\n- `theta`:  Tau variable\n\nidx: theta.t[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.remove-4","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.remove","text":"remove(T::Tau, idx::Int, rng=GLOBAL_RNG)\n\nPropose to remove old tau in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.remove-Union{Tuple{D}, Tuple{QuantumStatistics.MonteCarlo.FermiK{D},Int64}, Tuple{QuantumStatistics.MonteCarlo.FermiK{D},Int64,Any}} where D","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.remove","text":"removeFermiK!(oldK, Kf=1.0, δK=0.5, rng=GLOBAL_RNG)\n\nPropose to remove an existing Fermi K in [Kf-δK, Kf+δK)\n\nArguments\n\noldK:  vector of dimension of d=2 or 3\n\n\n\n\n\n","category":"method"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.sample-Tuple{QuantumStatistics.MonteCarlo.Configuration,Function,Function}","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.sample","text":"sample(config::Configuration, integrand::Function, measure::Function; Nblock=16, print=0, printio=stdout, save=0, saveio=nothing, timer=[])\n\nsample the integrands, collect statistics, and return the expected values and errors.\n\nRemarks\n\nUser may run the MC in parallel using MPI. Simply run mpiexec -n N julia userscript.jl where N is the number of workers. In this mode, only the root process returns meaningful results. All other workers return nothing, nothing. User is responsible to handle the returning results properly.\nIn the MC, a normalization diagram is introduced to normalize the MC estimates of the integrands. More information can be found in the link: https://kunyuan.github.io/QuantumStatistics.jl/dev/man/important_sampling/#Important-Sampling. User don't need to explicitly specify this normalization diagram.Internally, normalization diagram will be added to each table that is related to the integrands.\n\nArguments\n\nconfig: Configuration struct\nintegrand: function call to evaluate the integrand. It should accept an argument of the type Configuration, and return a weight.   Internally, MC only samples the absolute value of the weight. Therefore, it is also important to define Main.abs for the weight if its type is user-defined. \nmeasure: function call to measure. It should accept an argument of the type Configuration, then manipulate observables obs. \nNblock: repeat times. The tasks will automatically distributed to multi-process in MPI mode.\nprint: -1 to not print anything, 0 to print minimal information, >0 to print summary for every print seconds\nprintio: io to print the information\nsave: -1 to not save anything, 0 to save observables obs in the end of sampling, >0 to save observables obs for every save seconds\nsaveio: io to save\n\n\n\n\n\n","category":"method"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.shift!","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.shift!","text":"shiftIdx!(oldIdx::Int, newIdx::Int, size::Int, rng=GLOBAL_RNG)\n\nPropose to shift the old index in [1, size] to a new index\n\nArguments\n\noldIdx:  old index ∈ [1, size]\nnewIdx:  new index ∈ [1, size], will be modified!\nsize : up limit of the index\nrng=GLOBAL_RNG : random number generator\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.shift!-2","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.shift!","text":"shift!(T::TauPair, idx::Int, rng=GLOBAL_RNG)\n\nPropose to shift an existing tau pair to a new tau pair, both in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.t[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.shift!-3","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.shift!","text":"shift!(theta::Angle, idx::Int, rng=GLOBAL_RNG)\n\nPropose to shift the old theta to new theta, both in [0, 2π), return proposal probability\n\nArguments\n\ntheta:  angle variable\nidx: theta.t[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.shift!-4","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.shift!","text":"shift!(T::Tau, idx::Int, rng=GLOBAL_RNG)\n\nPropose to shift an existing tau to a new tau, both in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"function"},{"location":"lib/montecarlo/#QuantumStatistics.MonteCarlo.shift!-Union{Tuple{D}, Tuple{QuantumStatistics.MonteCarlo.FermiK{D},Int64}, Tuple{QuantumStatistics.MonteCarlo.FermiK{D},Int64,Any}} where D","page":"Monte Carlo","title":"QuantumStatistics.MonteCarlo.shift!","text":"shiftK!(oldK, newK, step, rng=GLOBAL_RNG)\n\nPropose to shift oldK to newK. Work for generic momentum vector\n\n\n\n\n\n","category":"method"},{"location":"man/important_sampling/#Important-Sampling","page":"Monte Carlo integrator","title":"Important Sampling","text":"","category":"section"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Consider the MC sampling of an one-dimensional functions f(x) (its sign may oscillate).","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"We want to design an efficient algorithm to calculate the integral int_a^b dx f(x). To do that, we normalize the integrand with an ansatz g(x)0 to reduce the variant. ","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Our package supports two important sampling schemes. ","category":"page"},{"location":"man/important_sampling/#Approach-1:-Algorithm-with-a-Normalization-Section","page":"Monte Carlo integrator","title":"Approach 1: Algorithm with a Normalization Section","text":"","category":"section"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"In this approach, the configuration spaces consist of two sub-spaces: the physical sector with orders nge 1 and the normalization sector with the order n=0. The weight function of the latter, g(x), should be simple enough so that the integral G=int g(x) d x is explicitly known. In our algorithm we use a constant g(x) propto 1 for simplicity. In this setup, the physical sector weight, namely the integral F = int f(x) dx, can be calculated with the equation","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"    F=fracF_rm MCG_rm MC G","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"where the MC estimators F_rm MC and G_rm MC are measured with ","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"F_rm MC =frac1N left sum_i=1^N_f fracf(x_i)rho_f(x_i) + sum_i=1^N_g 0 right","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"and","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"G_rm MC =frac1N leftsum_i=1^N_f 0 + sum_i=1^N_g fracg(x_i)rho_g(x_i)  right","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"The probability density of a given configuration is proportional to rho_f(x)=f(x) and rho_g(x)=g(x), respectively. After N MC updates, the physical sector is sampled for N_f times, and the normalization sector is for N_g times. ","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Now we estimate the statistic error. According to the propagation of uncertainty, the variance of F  is given by","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":" fracsigma^2_FF^2 =  fracsigma_F_rm MC^2F_MC^2 + fracsigma_G_rm MC^2G_MC^2 ","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"where sigma_F_rm MC and sigma_G_rm MC are variance of the MC integration F_rm MC and G_rm MC, respectively. In the Markov chain MC, the variance of F_rm MC can be written as ","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"sigma^2_F_rm MC = frac1N left sum_i^N_f left( fracf(x_i)rho_f(x_i)- fracFZright)^2 +sum_j^N_g left(0-fracFZ right)^2  right ","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"= int left( fracf(x)rho_f(x) - fracFZ right)^2 fracrho_f(x)Z rm dx + int left( fracFZ right)^2 fracrho_g(x)Z dx ","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"=  int fracf^2(x)rho_f(x) fracdxZ -fracF^2Z^2 ","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Here Z=Z_f+Z_g and Z_fg=int rho_fg(x)dx are the partition sums of the corresponding configuration spaces. Due to the detailed balance, one has Z_fZ_g=N_fN_g.  ","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Similarly, the variance of G_rm MC can be written as ","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"sigma^2_G_rm MC=  int fracg^2(x)rho_g(x) fracrm dxZ - fracG^2Z^2","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"By substituting rho_f(x)=f(x) and  rho_g(x)=g(x), the variances of F_rm MC and G_rm MC are given by","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"sigma^2_F_rm MC= frac1Z^2 left( Z Z_f - F^2 right)","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"sigma^2_G_rm MC= frac1Z^2 left( Z Z_g - G^2 right)","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"We derive the variance of F as","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracsigma^2_FF^2 = fracZ cdot Z_fF^2+fracZ cdot Z_gG^2 - 2 ","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Note that g(x)0 indicates Z_g = G,  so that","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracsigma^2_FF^2 = fracZ_f^2F^2+fracGcdot Z_fF^2+fracZ_fG - 1","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Interestingly, this variance is a function of G instead of a functional of g(x). It is then possible to normalized g(x) with a constant to minimize the variance. The optimal constant makes G to be,","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracd sigma^2_FdG=0","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"which makes G_best = F. The minimized the variance is given by,","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracsigma^2_FF^2= left(fracZ_fF+1right)^2 - 2ge 0","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"The equal sign is achieved when f(x)0 is positively defined.","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"It is very important that the above analysis is based on the assumption that the autocorrelation time negligible. The autocorrelation time related to the jump between the normalization and physical sectors is controlled by the deviation of the ratio f(x)g(x) from unity. The variance sigma_F^2 given above will be amplified to sim sigma_F^2 tau where tau is the autocorrelation time.","category":"page"},{"location":"man/important_sampling/#Approach-2:-Conventional-algorithm-(e.g.,-Vegas-algorithm)","page":"Monte Carlo integrator","title":"Approach 2: Conventional algorithm (e.g., Vegas algorithm)","text":"","category":"section"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Important sampling is actually more straightforward than the above approach. One simply sample x with a distribution rho_g(x)=g(x)Z_g, then measure the observable f(x)g(x). Therefore, the mean estimation,","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracFZ=int dx fracf(x)g(x) rho_g(x)","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"the variance of F in this approach is given by,","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"sigma_F^2=Z_g^2int dx left( fracf(x)g(x)- fracFZ_gright)^2rho_g(x)","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracsigma_F^2F^2=fracZ_gF^2int dx fracf(x)^2g(x)- 1","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"The optimal g(x) that minimizes the variance is g(x) =f(x),","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracsigma_F^2F^2=fracZ_f^2F^2-1","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"The variance of the conventional approach is a functional of g(x), while that of the previous approach isn't. There are two interesting limit:\nIf the f(x)0, the optimal choice g(x)=f(x) leads to zero variance. In this limit, the conventional approach is clearly much better than the previous approach.\nOn the other hand, if g(x) is far from the optimal choice f(x), say simply setting g(x)=1, one naively expect that the the conventional approach may leads to much larger variance than the previous approach. However,  this statement may not be true. If g(x) is very different from f(x), the normalization and the physical sector in the previous approach mismatch, causing large autocorrelation time and large statistical error . In contrast, the conventional approach doesn't have this problem.","category":"page"},{"location":"man/important_sampling/#Benchmark","page":"Monte Carlo integrator","title":"Benchmark","text":"","category":"section"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"To benchmark, we sample the following integral up to 10^8 updates, ","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"int_0^beta e^-(x-beta2)^2delta^2dx approx sqrtpidelta","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"where beta gg delta.","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"g(x)=f(x)","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Normalization Sector:  doesn't lead to exact result, the variance left(fracZ_fF+1right)^2 - 2=2 doesn't change with parameters","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"beta 10 100\nresult 0.1771(1) 0.1773(1)","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Conventional: exact result","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"g(x)=sqrtpideltabeta1","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"beta 10 100\nNormalization 0.1772(4) 0.1767(17)\nConventional 0.1777(3) 0.1767(8)","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"g(x)=exp(-(x-beta2+s)^2delta^2) with beta=100","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"s delta 2delta 3delta 4delta 5delta\nNormalization 0.1775(8) 0.1767(25) 0.1770(60) 0.176(15) 183(143)\nConventional 0.1776(5) 0.1707(39) 0.1243(174) 0.0204 (64) ","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"The conventional algorithm is not ergodic anymore for s=4delta, the acceptance ratio to update x is about 015, while the normalization algorithm becomes non ergodic for s=5delta. So the latter is slightly more stable.","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"<!– The code are ![[test.jl]] for the normalization approach and ![[test2.jl]] for the conventional approach. –>","category":"page"},{"location":"man/important_sampling/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Reference:  [1] Wang, B.Z., Hou, P.C., Deng, Y., Haule, K. and Chen, K., Fermionic sign structure of high-order Feynman diagrams in a many-fermion system. Physical Review B, 103, 115141 (2021).","category":"page"},{"location":"lib/spectral/#Spectral-functions","page":"Spectral functions","title":"Spectral functions","text":"","category":"section"},{"location":"lib/spectral/","page":"Spectral functions","title":"Spectral functions","text":"Modules = [QuantumStatistics.Spectral]","category":"page"},{"location":"lib/spectral/#QuantumStatistics.Spectral","page":"Spectral functions","title":"QuantumStatistics.Spectral","text":"Spectral representation related functions\n\n\n\n\n\n","category":"module"},{"location":"lib/spectral/#QuantumStatistics.Spectral.boseEinstein-Union{Tuple{T}, Tuple{T}, Tuple{T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.boseEinstein","text":"boseEinstein(ω)\n\nCompute the Fermi Dirac function. Assume k_B Thbar=1\n\nf(ω) = 1(e^ωβ-1)\n\nArguments\n\nω: frequency\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.density-Union{Tuple{T}, Tuple{Symbol,T}, Tuple{Symbol,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.density","text":"density(type, ω, β=1.0)\n\nCompute the imaginary-time kernel of different type. Assume k_B Thbar=1\n\nArguments\n\ntype: symbol :fermi, :bose\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.fermiDirac-Union{Tuple{T}, Tuple{T}, Tuple{T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.fermiDirac","text":"fermiDirac(ω)\n\nCompute the Fermi Dirac function. Assume k_B Thbar=1\n\nf(ω) = 1(e^ωβ+1)\n\nArguments\n\nω: frequency\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.freq2matfreq","page":"Spectral functions","title":"QuantumStatistics.Spectral.freq2matfreq","text":"freq2matfreq(type, spectral, nGrid, β=1.0, Emin=-Inf, Emax=Inf, rtol=1e-12)\n\nCompute Matubra frequency Green's function from a spectral density``\n\nG(iωn) = dω -1(iωn-ω) S(ω)\nwhere ωn=(2n+1)πβ for fermion and ωn=2nπβ\n\nArguments\n\ntype: :fermi, :boson\nspectral: call spectral(ω) returns the spectral density\nnGrid: array of Matsubara frequency (integer!) to evaluate\nβ=1.0: inverse temperature\nEmin=-Inf: lower bound of frequency\nEmax=Inf: upper bound of frequency\nrtol=1e-12: accuracy to achieve\n\n\n\n\n\n","category":"function"},{"location":"lib/spectral/#QuantumStatistics.Spectral.freq2tau","page":"Spectral functions","title":"QuantumStatistics.Spectral.freq2tau","text":"freq2tau(type, spectral, τGrid, β=1.0, Emin=-Inf, Emax=Inf, rtol=1e-12)\n\nCompute imaginary-time Green's function from a spectral density``\n\nG(τ0) = dω e^-ωτ(1e^-ωβ) S(ω)\nG(τ0) = -dω e^-ωτ(1e^ωβ) S(ω)\n\nArguments\n\ntype: :fermi, :boson\nintegrator: :quadgk, :vegas, :cuhre\nspectral: call spectral(ω) returns the spectral density\nτGrid: array of imaginary times to evaluate\nβ=1.0: inverse temperature\nEmin=-Inf: lower bound of frequency\nEmax=Inf: upper bound of frequency\nrtol=1e-12: accuracy to achieve\n\n\n\n\n\n","category":"function"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelBoseT-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelBoseT","text":"kernelBoseT(τ, ω, β=1.0)\n\nCompute the imaginary-time bosonic kernel. Machine accuracy ~eps(g) is guaranteed``\n\ng(τ0) = e^-ωτ(1-e^-ωβ) g(τ0) = -e^-ωτ(1-e^ωβ)\n\nArguments\n\nτ: the imaginary time, must be (-β, β]\nω: frequency\nβ = 1.0: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelBoseΩ-Union{Tuple{T}, Tuple{Int64,T}, Tuple{Int64,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelBoseΩ","text":"kernelBoseΩ(n::Int, ω::T, β::T) where {T <: AbstractFloat}\n\nCompute the bosonic kernel with Matsubara frequency.\n\ng(iω_n) = -1(iω_n-ω)\n\nwhere ω_n=2nπβ. The convention here is consist with the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95\n\nArguments\n\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelCorrT-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelCorrT","text":"kernelCorrT(τ, ω, β=1.0)\n\nCompute the imaginary-time kernel for correlation function O(τ)O(0). Machine accuracy ~eps(C) is guaranteed``\n\nK(τ) = e^-ωτ+e^-ω(β-τ)\n\nArguments\n\nτ: the imaginary time, must be (-β, β]\nω: frequency\nβ = 1.0: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelCorrΩ-Union{Tuple{T}, Tuple{Int64,T}, Tuple{Int64,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelCorrΩ","text":"kernelCorrΩ(n::Int, ω::T, β::T) where {T <: AbstractFloat}\n\nCompute the Matsubara-frequency kernel for a correlator O(τ)O(0)_iω_n.\n\nK(iω_n) = frac2ωω^2+ω_n^2(1-e^-ωβ)\n\nwhere ω_n=2nπβ. The convention here is consist with the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95\n\nArguments\n\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelFermiT-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelFermiT","text":"kernelFermiT(τ, ω, β=1.0)\n\nCompute the imaginary-time fermionic kernel.  Machine accuracy ~eps(g) is guaranteed``\n\ng(τ0) = e^-ωτ(1+e^-ωβ) g(τ0) = -e^-ωτ(1+e^ωβ)\n\nArguments\n\nτ: the imaginary time, must be (-β, β]\nω: frequency\nβ = 1.0: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelFermiΩ-Union{Tuple{T}, Tuple{Int64,T}, Tuple{Int64,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelFermiΩ","text":"kernelFermiΩ(n::Int, ω::T, β::T) where {T <: AbstractFloat}\n\nCompute the fermionic kernel with Matsubara frequency.\n\ng(iω_n) = -1(iω_n-ω)\n\nwhere ω_n=(2n+1)πβ. The convention here is consist with the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95\n\nArguments\n\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelT-Union{Tuple{T}, Tuple{Symbol,AbstractArray{T,1},AbstractArray{T,1}}, Tuple{Symbol,AbstractArray{T,1},AbstractArray{T,1},Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelT","text":"kernelT(type::Symbol, τGrid::Vector{T}, ωGrid::Vector{T}, β::T=1.0) where {T<:AbstractFloat}\n\nCompute kernel with given τ and ω grids.\n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelT-Union{Tuple{T}, Tuple{Symbol,T,T}, Tuple{Symbol,T,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelT","text":"kernelT(type, τ, ω, β=1.0)\n\nCompute the imaginary-time kernel of different type.\n\nArguments\n\ntype: symbol :fermi, :bose, :corr\nτ: the imaginary time, must be (-β, β]\nω: frequency\nβ = 1.0: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelΩ-Union{Tuple{T}, Tuple{Symbol,Array{Int64,1},Array{T,1}}, Tuple{Symbol,Array{Int64,1},Array{T,1},Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelΩ","text":"kernelΩ(type::Symbol, nGrid::Vector{Int}, ωGrid::Vector{T}, β::T=1.0) where {T<:AbstractFloat}\n\nCompute kernel matrix with given ωn (integer!) and ω grids.\n\n\n\n\n\n","category":"method"},{"location":"lib/spectral/#QuantumStatistics.Spectral.kernelΩ-Union{Tuple{T}, Tuple{Symbol,Int64,T}, Tuple{Symbol,Int64,T,Any}} where T<:AbstractFloat","page":"Spectral functions","title":"QuantumStatistics.Spectral.kernelΩ","text":"kernelΩ(type, n, ω, β=1.0)\n\nCompute the imaginary-time kernel of different type. Assume k_B Thbar=1\n\nArguments\n\ntype: symbol :fermi, :bose, :corr\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"#QuantumStatistics.jl","page":"Home","title":"QuantumStatistics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A toolbox for quantum many-body field theory.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n\"man/important_sampling.md\"\n]\nDepth = 1","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/grid.md\",\n    \"lib/spectral.md\",\n    \"lib/dlr.md\",\n    \"lib/green.md\",\n    \"lib/twopoint.md\",\n    \"lib/montecarlo.md\",\n    \"lib/fastmath.md\",\n    \"lib/utility.md\",\n]\nDepth = 1","category":"page"},{"location":"lib/fastmath/#Fast-Math-Functions","page":"Fast Math Functions","title":"Fast Math Functions","text":"","category":"section"},{"location":"lib/fastmath/","page":"Fast Math Functions","title":"Fast Math Functions","text":"Modules = [QuantumStatistics.FastMath]","category":"page"},{"location":"lib/fastmath/#QuantumStatistics.FastMath","page":"Fast Math Functions","title":"QuantumStatistics.FastMath","text":"Provide a set of fast math functions\n\n\n\n\n\n","category":"module"},{"location":"lib/fastmath/#QuantumStatistics.FastMath.invsqrt-Tuple{Float64}","page":"Fast Math Functions","title":"QuantumStatistics.FastMath.invsqrt","text":"invsqrt(x)\n\nThe Legendary Fast Inverse Square Root See the following links: wikipedia and thesis\n\n\n\n\n\n","category":"method"},{"location":"lib/grid/#Grids","page":"Grids","title":"Grids","text":"","category":"section"},{"location":"lib/grid/","page":"Grids","title":"Grids","text":"Modules = [QuantumStatistics.Grid]","category":"page"},{"location":"lib/grid/#QuantumStatistics.Grid.Uniform","page":"Grids","title":"QuantumStatistics.Grid.Uniform","text":"Uniform{Type,SIZE}\n\nCreate a uniform Grid with a given type and size\n\nMember:\n\nβ: inverse temperature\nhalfLife: the grid is densest in the range (0, halfLife) and (β-halfLife, β)\nsize: the Grid size\ngrid: vector stores the grid\nsize: size of the grid vector\nhead: grid head\ntail: grid tail\nδ: distance between two grid elements\nisopen: if isopen[1]==true, then grid[1] will be slightly larger than the grid head. Same for the tail.\n\n\n\n\n\n","category":"type"},{"location":"lib/grid/#QuantumStatistics.Grid.boseK","page":"Grids","title":"QuantumStatistics.Grid.boseK","text":"boseK(Kf, maxK, halfLife, size::Int, kFi = floor(Int, 0.5size), twokFi = floor(Int, 2size / 3), type = Float64)\n\nCreate a logarithmic bosonic K Grid, which is densest near the momentum 0 and 2k_F\n\n#Arguments:\n\nKf: Fermi momentum\nmaxK: the upper bound of the grid\nhalfLife: the grid is densest in the range (0, Kf+halfLife) and (2Kf-halfLife, 2Kf+halfLife)\nsize: the Grid size\nkFi: index of Kf\ntwokFi: index of 2Kf\n\n\n\n\n\n","category":"function"},{"location":"lib/grid/#QuantumStatistics.Grid.fermiK","page":"Grids","title":"QuantumStatistics.Grid.fermiK","text":"fermiK(Kf, maxK, halfLife, size::Int, kFi = floor(Int, 0.5size), type = Float64)\n\nCreate a logarithmic fermionic K Grid, which is densest near the Fermi momentum k_F\n\n#Arguments:\n\nKf: Fermi momentum\nmaxK: the upper bound of the grid\nhalfLife: the grid is densest in the range (Kf-halfLife, Kf+halfLife)\nsize: the Grid size\nkFi: index of Kf\n\n\n\n\n\n","category":"function"},{"location":"lib/grid/#QuantumStatistics.Grid.linear2D-NTuple{5,Any}","page":"Grids","title":"QuantumStatistics.Grid.linear2D","text":"linear2D(xgrid, ygrid, data, x, y) \n\nlinear interpolation of data(x, y)\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\nygrid: one-dimensional grid of y\ndata: two-dimensional array of data\nx: x\ny: y\n\n\n\n\n\n","category":"method"},{"location":"lib/grid/#QuantumStatistics.Grid.tau","page":"Grids","title":"QuantumStatistics.Grid.tau","text":"tau(β, halfLife, size::Int, type = Float64)\n\nCreate a logarithmic Grid for the imaginary time, which is densest near the 0 and β\n\n#Arguments:\n\nβ: inverse temperature\nhalfLife: the grid is densest in the range (0, halfLife) and (β-halfLife, β)\nsize: the Grid size\n\n\n\n\n\n","category":"function"}]
}
